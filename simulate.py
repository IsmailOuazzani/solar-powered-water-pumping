"""
For all the variables, we use the following units (unless explicitely stated):
Volume: mÂ³
Energy: Watt
Temperature: Celsius (unfortunate choice due to pvlib)
"""
from data import import_merra2_dataset, DATASETS
from geography import mask_lon_lat, plot_heatmap
from pvsystem import make_pv_system
import pvlib
import pandas as pd
from tqdm import tqdm
import matplotlib.pyplot as plt

import logging
import numpy as np
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG)


pumping_head = 45  # meters
pump_efficiency = 0.4
inverter_efficiency = 0.95
hourly_water_need = 60 / 24  # m^3/hour
storage_factor = 0.65  # optimal result in the paper
number_solar_panels = 43  # optimal result in the paper
hydraulic_constant = 2.725

def calculate_volume_water_pumped(num_panels, power, time_range, head, pump_eff, inverter_eff, hydraulic_const):
    return (num_panels * power * time_range * pump_eff * inverter_eff) / (hydraulic_const * head)

def calculate_volume_water_consumed(hourly_need, time_range):
    return hourly_need * time_range

def plot_water_simulation(results, time_range, tank_capacity, title):
    """
    Plot water simulation for a specified time range.
    """
    results.loc[time_range, "water_pumped"].plot()
    results.loc[time_range, "water_consumed"].plot()
    results.loc[time_range, "water_in_tank"].plot()

    plt.axhline(y=tank_capacity, color='r', linestyle='--', label="Tank capacity")
    plt.legend(["Water pumped", "Water consumed", "Water in tank", "Tank capacity"])
    plt.title(title)
    plt.ylabel("Water (m^3)")
    plt.savefig("outputs/water_in_tank.png")



if __name__ == "__main__":
    solar_radiation_ds = import_merra2_dataset(
        DATASETS["M2T1NXRAD_5-2023_only_SWGDN"], variables=["SWGDN"])
    
    lon = solar_radiation_ds['lon'].values  # Replace 'lon' with your longitude coordinate name
    lat = solar_radiation_ds['lat'].values  # Replace 'lat' with your latitude coordinate name


    lon_lat_pairs = mask_lon_lat(lon,lat)
    logging.info(f"Masked {100*(1-len(lon_lat_pairs)/(len(lon)*len(lat)))}% of data points.")

    pv_outputs = []
    pv_outputs_sums = []


    final_water_levels_jan1 = []
    for longitude, latitude in tqdm(lon_lat_pairs):
        logging.info(f"Simulating system at {longitude}, {latitude}...")
        location_radiation_ds = solar_radiation_ds.sel(lat=latitude, lon=longitude, method=None)

        pv_system = make_pv_system(latitude=latitude, longitude=longitude)
        weather = location_radiation_ds.to_dataframe()
        weather = weather.rename(columns={"SWGDN": "ghi"}) # for compatibility with pvlib
        solar_position = pvlib.solarposition.get_solarposition(location_radiation_ds.time, latitude, longitude)
        weather["dni"] = pvlib.irradiance.disc(ghi=weather.ghi, solar_zenith=solar_position.zenith, datetime_or_doy=weather.index)["dni"] #TODO: try other models for dni
        weather["dhi"] =  - np.cos(np.radians(solar_position.zenith)) * weather.dni + weather.ghi # GHI = DHI + DNI * cos(zenith) https://www.researchgate.net/figure/Equation-of-calculating-GHI-using-DNI-and-DHI_fig1_362326479#:~:text=The%20quantity%20of%20solar%20radiation,)%20%2BDHI%20%5B12%5D%20.

        sim_out = pv_system.run_model(weather).results
        results = pd.DataFrame({"power":sim_out.ac})
        # clip the power to zero, as negative power does not make sense?
        results.power = results.power.clip(lower=0)
        results.power = results.power.fillna(0) # Don't need to do this when using other solar panels ...


        results["water_pumped"] = calculate_volume_water_pumped(
            number_solar_panels,
            results.power,
            time_range=1,
            head=pumping_head,
            pump_eff=pump_efficiency,
            inverter_eff=inverter_efficiency,
            hydraulic_const=hydraulic_constant
        )
        results["water_consumed"] = calculate_volume_water_consumed(hourly_water_need, time_range=1)

        tank_capacity = 24 * storage_factor * hourly_water_need  # in m^3
        water_in_tank = [tank_capacity]  # Start with a full tank

        for i in range(1, len(results)):
            new_water_level = water_in_tank[-1] + (results["water_pumped"].iloc[i] - results["water_consumed"].iloc[i])
            constrained_water_level = min(max(new_water_level, 0), tank_capacity)
            water_in_tank.append(constrained_water_level)

        results["water_in_tank"] = water_in_tank

        pv_outputs.append(results)
        pv_outputs_sums.append(results.power.sum())
        final_water_levels_jan1.append(results.loc["2023-01-02 23:30:00", "water_in_tank"])

    first_data_point = pv_outputs[0]
    plot_water_simulation(first_data_point, "2023-04-04", tank_capacity, "System Simulation - January 1st, 2023")
    plot_heatmap(lon_lat_pairs=lon_lat_pairs, values=np.array(pv_outputs_sums), output_file="outputs/total_power.png", legend="Total power generated by the pv system (W)")    
    plot_heatmap(
        lon_lat_pairs=lon_lat_pairs,
        values=np.array(final_water_levels_jan1),
        output_file="outputs/water_in_tank_end_january_1st.png",
        legend="Final water in tank at end of January"
    )

    